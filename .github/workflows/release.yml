name: Build Standalone Release Executables

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build-linux:
    name: Build Linux Server (Static)
    runs-on: ubuntu-latest
    container:
      image: rust:alpine
    
    steps:
      - name: Install build dependencies
        run: |
          echo "https://dl-cdn.alpinelinux.org/alpine/edge/main" >> /etc/apk/repositories
          echo "https://dl-cdn.alpinelinux.org/alpine/edge/community" >> /etc/apk/repositories
          
          apk update
          apk add --no-cache \
            git \
            cmake \
            make \
            gcc \
            g++ \
            musl-dev \
            linux-headers \
            openssl-dev \
            openssl-libs-static \
            pkgconfig \
            bash \
            perl \
            file \
            binutils

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Pre-fetch and patch picotls
        run: |
          echo "Pre-fetching and building picotls..."

          # Clone picotls with submodules (includes picotest)
          mkdir -p /tmp/picotls-build
          git clone --depth 1 --recurse-submodules https://github.com/h2o/picotls.git /tmp/picotls-build/picotls

          # Patch the CMakeLists.txt to allow CMake 3.5
          cd /tmp/picotls-build/picotls
          sed -i 's/CMAKE_MINIMUM_REQUIRED(VERSION [0-9.]*)/CMAKE_MINIMUM_REQUIRED(VERSION 3.5)/' CMakeLists.txt

          echo "âœ… Cloned picotls with submodules"
          head -n 5 CMakeLists.txt

          # Build picotls libraries only (skip test targets)
          mkdir -p /tmp/picotls-build/picotls-build
          cmake -S /tmp/picotls-build/picotls -B /tmp/picotls-build/picotls-build \
            -DCMAKE_BUILD_TYPE=Release \
            -DOPENSSL_ROOT_DIR=/usr \
            -DOPENSSL_LIBRARIES=/usr/lib

          # Build only the library targets, not tests
          cmake --build /tmp/picotls-build/picotls-build --target picotls-core picotls-minicrypto picotls-openssl

          echo "âœ… Built picotls libraries"
          ls -la /tmp/picotls-build/picotls-build/*.a

      - name: Build picoquic
        run: |
          ROOT_DIR="$PWD"
          PICOQUIC_DIR="${ROOT_DIR}/vendor/picoquic"
          BUILD_DIR="${ROOT_DIR}/.picoquic-build"
          PICOQUIC_PATCHED_PTLS="/tmp/picotls-build"
          PICOQUIC_PATCHED_PTLS_BUILD="/tmp/picotls-build/picotls-build"

          echo "Building picoquic..."

          # Configure with the pre-built picotls
          cmake -S "${PICOQUIC_DIR}" -B "${BUILD_DIR}" \
            -DCMAKE_BUILD_TYPE=Release \
            -DPICOQUIC_FETCH_PTLS=OFF \
            -DPTLS_INCLUDE_DIR="${PICOQUIC_PATCHED_PTLS}/picotls/include" \
            -DPTLS_CORE_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-core.a" \
            -DPTLS_OPENSSL_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-openssl.a" \
            -DPTLS_MINICRYPTO_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-minicrypto.a"

          # Build picoquic
          cmake --build "${BUILD_DIR}"

          echo "âœ… Picoquic built successfully"

          # Debug: List what was actually created
          echo ""
          echo "=== Picoquic build directory contents ==="
          ls -la "${BUILD_DIR}/"
          echo ""
          echo "=== Picoquic library files (.a) ==="
          find "${BUILD_DIR}" -name "*.a" | sort
          echo ""
          echo "=== Picoquic subdirectories ==="
          find "${BUILD_DIR}" -type d | head -20

      - name: Copy picotls libraries for Rust build
        run: |
          # The Rust build script expects picotls libs in _deps/picotls-build
          mkdir -p .picoquic-build/_deps/picotls-build

          # Copy picotls libraries and report what was found
          echo "Copying picotls libraries..."
          for lib in /tmp/picotls-build/picotls-build/libpicotls-*.a; do
            if [ -f "$lib" ]; then
              cp "$lib" .picoquic-build/_deps/picotls-build/
              echo "âœ“ Copied: $(basename $lib)"
            fi
          done

          # Check for picotls-fusion (may not exist on all platforms)
          if [ -f "/tmp/picotls-build/picotls-build/libpicotls-fusion.a" ]; then
            echo "âœ“ picotls-fusion available"
          else
            echo "âš  picotls-fusion not available (CPU feature dependent)"
          fi

          echo ""
          echo "=== Copied picotls libraries ==="
          ls -la .picoquic-build/_deps/picotls-build/
          echo ""
          echo "=== All picoquic build files ==="
          find .picoquic-build -name "*.a" | sort

      - name: Set environment for static build
        run: |
          echo "OPENSSL_STATIC=1" >> $GITHUB_ENV
          echo "OPENSSL_LIB_DIR=/usr/lib" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=/usr/include" >> $GITHUB_ENV
          echo "PICOQUIC_AUTO_BUILD=0" >> $GITHUB_ENV
          echo "PICOQUIC_BUILD_DIR=$PWD/.picoquic-build" >> $GITHUB_ENV
          echo "PICOTLS_INCLUDE_DIR=/tmp/picotls-build/picotls/include" >> $GITHUB_ENV

      - name: Verify libraries before Rust build
        run: |
          echo "=== Verifying required libraries ==="

          # Check picoquic library
          if [ -f ".picoquic-build/libpicoquic-core.a" ]; then
            echo "âœ“ Found: .picoquic-build/libpicoquic-core.a"
          elif [ -f ".picoquic-build/libpicoquic_core.a" ]; then
            echo "âœ“ Found: .picoquic-build/libpicoquic_core.a"
          elif [ -f ".picoquic-build/picoquic/libpicoquic-core.a" ]; then
            echo "âœ“ Found: .picoquic-build/picoquic/libpicoquic-core.a"
          else
            echo "âœ— NOT FOUND: libpicoquic-core.a"
            echo "Searching for picoquic libraries:"
            find .picoquic-build -name "*picoquic*" 2>/dev/null || true
          fi

          # Check picotls libraries
          for lib in picotls-core picotls-minicrypto picotls-openssl; do
            if [ -f ".picoquic-build/_deps/picotls-build/lib$lib.a" ]; then
              echo "âœ“ Found: .picoquic-build/_deps/picotls-build/lib$lib.a"
            else
              echo "âœ— NOT FOUND: lib$lib.a"
            fi
          done

          echo ""
          echo "=== All .a files in build directory ==="
          find .picoquic-build -name "*.a" | sort

      - name: Build server
        run: |
          echo "Building slipstream-server..."
          cargo build --release --target x86_64-unknown-linux-musl -p slipstream-server
          echo "âœ… Server built successfully"

      - name: Verify static linking
        run: |
          BINARY="target/x86_64-unknown-linux-musl/release/slipstream-server"
          
          echo "=== Binary information ==="
          file "$BINARY"
          
          echo ""
          echo "=== File size (before strip) ==="
          ls -lh "$BINARY"
          
          echo ""
          echo "=== Checking dynamic dependencies ==="
          if ldd "$BINARY" 2>&1 | grep -q "not a dynamic executable"; then
            echo "âœ… SUCCESS: Fully static binary!"
          else
            echo "âš ï¸  Dynamic dependencies:"
            ldd "$BINARY" || true
          fi
          
          echo ""
          echo "=== Stripping debug symbols ==="
          strip "$BINARY"
          echo "Final size:"
          ls -lh "$BINARY"

      - name: Create release package
        run: |
          mkdir -p release/slipstream-server
          cp target/x86_64-unknown-linux-musl/release/slipstream-server release/slipstream-server/
          
          cat > release/slipstream-server/server.conf << 'EOF'
          # Slipstream Server Configuration
          DOMAIN=tunnel.example.com
          DNS_LISTEN_PORT=53
          TARGET_ADDRESS=127.0.0.1:5201
          CERT_PATH=./cert.pem
          KEY_PATH=./key.pem
          EOF
          
          cat > release/slipstream-server/start-server.sh << 'EOF'
          #!/bin/bash
          set -e
          
          if [ ! -f server.conf ]; then
              echo "âŒ Error: server.conf not found"
              exit 1
          fi
          
          source server.conf
          
          echo "================================================"
          echo "  Slipstream DNS Tunnel Server"
          echo "================================================"
          echo ""
          echo "Configuration:"
          echo "  Domain      : ${DOMAIN}"
          echo "  DNS Port    : ${DNS_LISTEN_PORT}"
          echo "  Target      : ${TARGET_ADDRESS}"
          echo "  Certificate : ${CERT_PATH}"
          echo "  Private Key : ${KEY_PATH}"
          echo ""
          
          if [ ! -f "${CERT_PATH}" ] || [ ! -f "${KEY_PATH}" ]; then
              echo "âŒ Error: Certificate files not found"
              echo "   Run: ./generate-cert.sh"
              exit 1
          fi
          
          echo "Starting server..."
          echo "Press Ctrl+C to stop"
          echo ""
          
          ./slipstream-server \
            --dns-listen-port ${DNS_LISTEN_PORT} \
            --target-address ${TARGET_ADDRESS} \
            --domain ${DOMAIN} \
            --cert ${CERT_PATH} \
            --key ${KEY_PATH}
          EOF
          chmod +x release/slipstream-server/start-server.sh
          
          cat > release/slipstream-server/generate-cert.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "Generating self-signed TLS certificate..."
          echo ""
          
          if ! command -v openssl &> /dev/null; then
              echo "âŒ Error: openssl command not found"
              echo ""
              echo "Install OpenSSL:"
              echo "  Ubuntu/Debian: sudo apt-get install openssl"
              echo "  CentOS/RHEL:   sudo yum install openssl"
              echo "  Alpine:        apk add openssl"
              exit 1
          fi
          
          openssl req -x509 -newkey rsa:2048 -nodes \
            -keyout key.pem -out cert.pem -days 365 \
            -subj "/CN=slipstream" \
            -addext "subjectAltName=DNS:tunnel.example.com,DNS:*.tunnel.example.com"
          
          chmod 600 key.pem
          chmod 644 cert.pem
          
          echo ""
          echo "âœ… Certificate generated: cert.pem, key.pem"
          EOF
          chmod +x release/slipstream-server/generate-cert.sh
          
          cat > release/slipstream-server/README.md << 'EOF'
          # Slipstream Server - Linux x86_64 (Fully Static)
          
          âœ… **Zero runtime dependencies - Works on ANY x86_64 Linux**
          
          ## Quick Start
          
          ```bash
          # 1. Generate certificates
          ./generate-cert.sh
          
          # 2. Configure (edit server.conf)
          nano server.conf
          
          # 3. Run (port 53 requires root)
          sudo ./start-server.sh
          ```
          
          ## Requirements
          
          **To run the server**: NOTHING (fully static binary)
          
          **To generate certificates** (one-time): `openssl` command
          ```bash
          sudo apt install openssl  # Ubuntu/Debian
          sudo yum install openssl  # CentOS/RHEL
          apk add openssl          # Alpine
          ```
          
          ## Configuration
          
          Edit `server.conf`:
          - `DOMAIN`: Your tunnel domain (e.g., tunnel.example.com)
          - `DNS_LISTEN_PORT`: 53 (production) or 8853 (testing)
          - `TARGET_ADDRESS`: Forwarding destination (e.g., 127.0.0.1:5201)
          
          ## Firewall
          
          ```bash
          # Ubuntu/Debian
          sudo ufw allow 53/udp
          
          # CentOS/RHEL/Fedora
          sudo firewall-cmd --permanent --add-port=53/udp
          sudo firewall-cmd --reload
          ```
          
          ## Testing
          
          ```bash
          # Check if listening
          sudo netstat -ulnp | grep 53
          
          # Test DNS
          dig @localhost -p 53 test.tunnel.example.com
          ```
          
          ## Documentation
          
          https://github.com/Mygod/slipstream-rust
          EOF
          
          cd release
          tar -czf slipstream-server-linux-x64-static.tar.gz slipstream-server/
          
          echo ""
          echo "=== Package created ==="
          ls -lh *.tar.gz

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: slipstream-server-linux-x64-static
          path: release/*.tar.gz

  build-linux-client:
    name: Build Linux Client (Static)
    runs-on: ubuntu-latest
    container:
      image: rust:alpine

    steps:
      - name: Install build dependencies
        run: |
          echo "https://dl-cdn.alpinelinux.org/alpine/edge/main" >> /etc/apk/repositories
          echo "https://dl-cdn.alpinelinux.org/alpine/edge/community" >> /etc/apk/repositories

          apk update
          apk add --no-cache \
            git \
            cmake \
            make \
            gcc \
            g++ \
            musl-dev \
            linux-headers \
            openssl-dev \
            openssl-libs-static \
            pkgconfig \
            bash \
            perl \
            file \
            binutils

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Pre-fetch and patch picotls
        run: |
          echo "Pre-fetching and building picotls..."

          # Clone picotls with submodules (includes picotest)
          mkdir -p /tmp/picotls-build
          git clone --depth 1 --recurse-submodules https://github.com/h2o/picotls.git /tmp/picotls-build/picotls

          # Patch the CMakeLists.txt to allow CMake 3.5
          cd /tmp/picotls-build/picotls
          sed -i 's/CMAKE_MINIMUM_REQUIRED(VERSION [0-9.]*)/CMAKE_MINIMUM_REQUIRED(VERSION 3.5)/' CMakeLists.txt

          echo "âœ… Cloned picotls with submodules"
          head -n 5 CMakeLists.txt

          # Build picotls libraries only (skip test targets)
          mkdir -p /tmp/picotls-build/picotls-build
          cmake -S /tmp/picotls-build/picotls -B /tmp/picotls-build/picotls-build \
            -DCMAKE_BUILD_TYPE=Release \
            -DOPENSSL_ROOT_DIR=/usr \
            -DOPENSSL_LIBRARIES=/usr/lib

          # Build only the library targets, not tests
          cmake --build /tmp/picotls-build/picotls-build --target picotls-core picotls-minicrypto picotls-openssl

          echo "âœ… Built picotls libraries"
          ls -la /tmp/picotls-build/picotls-build/*.a

      - name: Build picoquic
        run: |
          ROOT_DIR="$PWD"
          PICOQUIC_DIR="${ROOT_DIR}/vendor/picoquic"
          BUILD_DIR="${ROOT_DIR}/.picoquic-build"
          PICOQUIC_PATCHED_PTLS="/tmp/picotls-build"
          PICOQUIC_PATCHED_PTLS_BUILD="/tmp/picotls-build/picotls-build"

          echo "Building picoquic..."

          # Configure with the pre-built picotls
          cmake -S "${PICOQUIC_DIR}" -B "${BUILD_DIR}" \
            -DCMAKE_BUILD_TYPE=Release \
            -DPICOQUIC_FETCH_PTLS=OFF \
            -DPTLS_INCLUDE_DIR="${PICOQUIC_PATCHED_PTLS}/picotls/include" \
            -DPTLS_CORE_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-core.a" \
            -DPTLS_OPENSSL_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-openssl.a" \
            -DPTLS_MINICRYPTO_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-minicrypto.a"

          # Build picoquic
          cmake --build "${BUILD_DIR}"

          echo "âœ… Picoquic built successfully"

          # Debug: List what was actually created
          echo ""
          echo "=== Picoquic build directory contents ==="
          ls -la "${BUILD_DIR}/"
          echo ""
          echo "=== Picoquic library files (.a) ==="
          find "${BUILD_DIR}" -name "*.a" | sort
          echo ""
          echo "=== Picoquic subdirectories ==="
          find "${BUILD_DIR}" -type d | head -20

      - name: Copy picotls libraries for Rust build
        run: |
          # The Rust build script expects picotls libs in _deps/picotls-build
          mkdir -p .picoquic-build/_deps/picotls-build

          # Copy picotls libraries and report what was found
          echo "Copying picotls libraries..."
          for lib in /tmp/picotls-build/picotls-build/libpicotls-*.a; do
            if [ -f "$lib" ]; then
              cp "$lib" .picoquic-build/_deps/picotls-build/
              echo "âœ“ Copied: $(basename $lib)"
            fi
          done

          # Check for picotls-fusion (may not exist on all platforms)
          if [ -f "/tmp/picotls-build/picotls-build/libpicotls-fusion.a" ]; then
            echo "âœ“ picotls-fusion available"
          else
            echo "âš  picotls-fusion not available (CPU feature dependent)"
          fi

          echo ""
          echo "=== Copied picotls libraries ==="
          ls -la .picoquic-build/_deps/picotls-build/
          echo ""
          echo "=== All picoquic build files ==="
          find .picoquic-build -name "*.a" | sort

      - name: Set environment for static build
        run: |
          echo "OPENSSL_STATIC=1" >> $GITHUB_ENV
          echo "OPENSSL_LIB_DIR=/usr/lib" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=/usr/include" >> $GITHUB_ENV
          echo "PICOQUIC_AUTO_BUILD=0" >> $GITHUB_ENV
          echo "PICOQUIC_BUILD_DIR=$PWD/.picoquic-build" >> $GITHUB_ENV
          echo "PICOTLS_INCLUDE_DIR=/tmp/picotls-build/picotls/include" >> $GITHUB_ENV

      - name: Verify libraries before Rust build
        run: |
          echo "=== Verifying required libraries ==="

          # Check picoquic library
          if [ -f ".picoquic-build/libpicoquic-core.a" ]; then
            echo "âœ“ Found: .picoquic-build/libpicoquic-core.a"
          elif [ -f ".picoquic-build/libpicoquic_core.a" ]; then
            echo "âœ“ Found: .picoquic-build/libpicoquic_core.a"
          elif [ -f ".picoquic-build/picoquic/libpicoquic-core.a" ]; then
            echo "âœ“ Found: .picoquic-build/picoquic/libpicoquic-core.a"
          else
            echo "âœ— NOT FOUND: libpicoquic-core.a"
            echo "Searching for picoquic libraries:"
            find .picoquic-build -name "*picoquic*" 2>/dev/null || true
          fi

          # Check picotls libraries
          for lib in picotls-core picotls-minicrypto picotls-openssl; do
            if [ -f ".picoquic-build/_deps/picotls-build/lib$lib.a" ]; then
              echo "âœ“ Found: .picoquic-build/_deps/picotls-build/lib$lib.a"
            else
              echo "âœ— NOT FOUND: lib$lib.a"
            fi
          done

          echo ""
          echo "=== All .a files in build directory ==="
          find .picoquic-build -name "*.a" | sort

      - name: Build client
        run: |
          echo "Building slipstream-client..."
          cargo build --release --target x86_64-unknown-linux-musl -p slipstream-client
          echo "âœ… Client built successfully"

      - name: Verify static linking
        run: |
          BINARY="target/x86_64-unknown-linux-musl/release/slipstream-client"

          echo "=== Binary information ==="
          file "$BINARY"

          echo ""
          echo "=== File size (before strip) ==="
          ls -lh "$BINARY"

          echo ""
          echo "=== Checking dynamic dependencies ==="
          if ldd "$BINARY" 2>&1 | grep -q "not a dynamic executable"; then
            echo "âœ… SUCCESS: Fully static binary!"
          else
            echo "âš ï¸  Dynamic dependencies:"
            ldd "$BINARY" || true
          fi

          echo ""
          echo "=== Stripping debug symbols ==="
          strip "$BINARY"
          echo "Final size:"
          ls -lh "$BINARY"

      - name: Create release package
        run: |
          mkdir -p release/slipstream-client
          cp target/x86_64-unknown-linux-musl/release/slipstream-client release/slipstream-client/

          cat > release/slipstream-client/client.conf << 'EOF'
          # Slipstream Client Configuration
          DOMAIN=tunnel.example.com
          RESOLVER=YOUR_SERVER_IP:53
          TCP_LISTEN_PORT=7000
          CONGESTION_CONTROL=dcubic
          EOF

          cat > release/slipstream-client/start-client.sh << 'EOF'
          #!/bin/bash
          set -e

          if [ ! -f client.conf ]; then
              echo "âŒ Error: client.conf not found"
              exit 1
          fi

          source client.conf

          if [ "$RESOLVER" = "YOUR_SERVER_IP:53" ]; then
              echo "âŒ Error: Configure RESOLVER in client.conf"
              exit 1
          fi

          echo "================================================"
          echo "  Slipstream DNS Tunnel Client"
          echo "================================================"
          echo ""
          echo "Configuration:"
          echo "  Domain      : ${DOMAIN}"
          echo "  Resolver    : ${RESOLVER}"
          echo "  Listen Port : ${TCP_LISTEN_PORT}"
          echo ""

          echo "Starting client..."
          echo "Press Ctrl+C to stop"
          echo ""

          ./slipstream-client \
            --domain ${DOMAIN} \
            --resolver ${RESOLVER} \
            --tcp-listen-port ${TCP_LISTEN_PORT} \
            --congestion-control ${CONGESTION_CONTROL}
          EOF
          chmod +x release/slipstream-client/start-client.sh

          cat > release/slipstream-client/README.md << 'EOF'
          # Slipstream Client - Linux x86_64 (Fully Static)

          âœ… **Zero runtime dependencies - Works on ANY x86_64 Linux**

          ## Quick Start

          ```bash
          # 1. Configure (edit client.conf)
          nano client.conf

          # 2. Run
          ./start-client.sh

          # 3. Use SOCKS5 proxy
          curl --proxy socks5://127.0.0.1:7000 http://example.com
          ```

          ## Requirements

          **To run the client**: NOTHING (fully static binary)

          Works on: Any x86_64 Linux distribution (Ubuntu, Debian, CentOS, Alpine, etc.)

          ## Configuration

          Edit `client.conf`:
          - `DOMAIN`: Your tunnel domain (e.g., tunnel.example.com)
          - `RESOLVER`: DNS server IP (your server's IP)
          - `TCP_LISTEN_PORT`: Local SOCKS5 proxy port (default: 7000)
          - `CONGESTION_CONTROL`: Congestion algorithm (dcubic, bbr, cubic)

          ## Testing

          ```bash
          # Test SOCKS5 proxy
          curl --proxy socks5://127.0.0.1:7000 http://example.com

          # Test with SSH
          ssh -o ProxyCommand="nc -X 5 -x 127.0.0.1:7000 %h %p" user@remote
          ```

          ## Documentation

          https://github.com/Mygod/slipstream-rust
          EOF

          cd release
          tar -czf slipstream-client-linux-x64-static.tar.gz slipstream-client/

          echo ""
          echo "=== Package created ==="
          ls -lh *.tar.gz

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: slipstream-client-linux-x64-static
          path: release/*.tar.gz

  build-windows:
    name: Build Windows Client (Static)
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install vcpkg
        shell: pwsh
        run: |
          git clone https://github.com/Microsoft/vcpkg.git C:\vcpkg
          cd C:\vcpkg
          .\bootstrap-vcpkg.bat
          .\vcpkg integrate install

      - name: Install OpenSSL (static)
        shell: pwsh
        run: |
          cd C:\vcpkg
          .\vcpkg install openssl:x64-windows-static

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-pc-windows-msvc

      - name: Cache vcpkg
        uses: actions/cache@v4
        with:
          path: C:\vcpkg\installed
          key: windows-vcpkg-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: windows-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Pre-fetch and patch picotls
        shell: pwsh
        run: |
          Write-Host "Pre-fetching and building picotls..."

          New-Item -ItemType Directory -Force -Path "C:\tmp\picotls-build"
          git clone --depth 1 --recurse-submodules https://github.com/h2o/picotls.git C:\tmp\picotls-build\picotls

          cd C:\tmp\picotls-build\picotls

          # Patch CMakeLists.txt for Windows build
          $content = Get-Content CMakeLists.txt -Raw
          # Change CMake minimum version
          $content = $content -replace 'CMAKE_MINIMUM_REQUIRED\(VERSION [0-9.]+\)', 'CMAKE_MINIMUM_REQUIRED(VERSION 3.5)'
          # Make PkgConfig optional (remove REQUIRED)
          $content = $content -replace 'FIND_PACKAGE\(PkgConfig REQUIRED\)', 'FIND_PACKAGE(PkgConfig)'
          # Make PKG_CHECK_MODULES conditional - use actual newlines via regex replace
          $content = $content -replace 'PKG_CHECK_MODULES\((\w+)\)', {
            param($match)
            "IF(PkgConfig_FOUND)`nPKG_CHECK_MODULES($($match.Groups[1].Value))`nENDIF()"
          }
          Set-Content CMakeLists.txt -Value $content

          Write-Host "âœ… Patched picotls for Windows"
          Get-Content CMakeLists.txt -Head 5

          # Build picotls libraries only (skip test targets that fail on Windows)
          New-Item -ItemType Directory -Force -Path "C:\tmp\picotls-build\picotls-build"

          # Set include paths for picotls to find its own headers (wincompat.h, etc.)
          $PicotlsSource = "C:\tmp\picotls-build\picotls"
          $PicotlsInclude = "C:\tmp\picotls-build\picotls\include"
          $CFlags = "-I`"$PicotlsInclude`" -I`"$PicotlsSource\lib`" -I`"$PicotlsSource`""

          cmake -S C:\tmp\picotls-build\picotls -B C:\tmp\picotls-build\picotls-build `
            -DCMAKE_BUILD_TYPE=Release `
            -DOPENSSL_ROOT_DIR=C:\vcpkg\installed\x64-windows-static `
            -DOPENSSL_INCLUDE_DIR=C:\vcpkg\installed\x64-windows-static\include `
            -DOPENSSL_CRYPTO_LIBRARY=C:\vcpkg\installed\x64-windows-static\lib\libcrypto.lib `
            -DOPENSSL_SSL_LIBRARY=C:\vcpkg\installed\x64-windows-static\lib\libssl.lib `
            -DCMAKE_C_FLAGS="$CFlags" `
            -DCMAKE_SHARED_C_FLAGS="$CFlags" `
            -A x64

          # Build only the library targets, not tests
          cmake --build C:\tmp\picotls-build\picotls-build --config Release --target picotls-core picotls-minicrypto picotls-openssl

          Write-Host "âœ… Built picotls libraries"
          if (Test-Path "C:\tmp\picotls-build\picotls-build\Release\*.lib") {
            Get-ChildItem C:\tmp\picotls-build\picotls-build\Release\*.lib
          } else {
            Write-Host "Warning: No .lib files found in Release directory"
            Get-ChildItem -Recurse C:\tmp\picotls-build\picotls-build\*.lib
          }

      - name: Build picoquic
        shell: pwsh
        run: |
          $PICOQUIC_DIR = "$PWD\vendor\picoquic"
          $BUILD_DIR = "$PWD\.picoquic-build"
          $PICOQUIC_PATCHED_PTLS = "C:\tmp\picotls-build"
          $PICOQUIC_PATCHED_PTLS_BUILD = "C:\tmp\picotls-build\picotls-build\Release"

          Write-Host "Building picoquic..."

          cmake -S $PICOQUIC_DIR -B $BUILD_DIR `
            -DCMAKE_BUILD_TYPE=Release `
            -DPICOQUIC_FETCH_PTLS=OFF `
            -DPTLS_INCLUDE_DIR="$PICOQUIC_PATCHED_PTLS\picotls\include" `
            -DPTLS_CORE_LIBRARY="$PICOQUIC_PATCHED_PTLS_BUILD\picotls-core.lib" `
            -DPTLS_OPENSSL_LIBRARY="$PICOQUIC_PATCHED_PTLS_BUILD\picotls-openssl.lib" `
            -DPTLS_MINICRYPTO_LIBRARY="$PICOQUIC_PATCHED_PTLS_BUILD\picotls-minicrypto.lib" `
            -A x64

          cmake --build $BUILD_DIR --config Release

          Write-Host "âœ… Picoquic built"

      - name: Copy picotls libraries for Rust build
        shell: pwsh
        run: |
          # The Rust build script expects picotls libs in _deps\picotls-build
          New-Item -ItemType Directory -Force -Path ".picoquic-build\_deps\picotls-build"

          # Copy picotls libraries individually for better error handling
          $libraries = @("picotls-core", "picotls-openssl", "picotls-minicrypto", "picotls-fusion")
          $sourceDir = "C:\tmp\picotls-build\picotls-build\Release"
          $destDir = ".picoquic-build\_deps\picotls-build"

          $copied = 0
          foreach ($lib in $libraries) {
            $libFile = "$sourceDir\$lib.lib"
            if (Test-Path $libFile) {
              Copy-Item $libFile $destDir
              Write-Host "âœ“ Copied: $lib.lib"
              $copied++
            } else {
              Write-Host "âœ— Not found (optional): $lib.lib"
            }
          }

          Write-Host ""
          Write-Host "=== Copied $copied picotls libraries ==="
          Get-ChildItem $destDir\
          Write-Host ""
          Write-Host "=== All picoquic build files ==="
          Get-ChildItem -Recurse .picoquic-build\*.lib

      - name: Verify libraries before Rust build
        shell: pwsh
        run: |
          Write-Host "=== Verifying required libraries ==="

          # Check picoquic library
          $PicoquicLib = ".picoquic-build\picoquic-core.lib"
          if (Test-Path $PicoquicLib) {
            Write-Host "âœ“ Found: $PicoquicLib"
          } else {
            Write-Host "âœ— NOT FOUND: picoquic-core.lib"
            Write-Host "Searching for picoquic libraries:"
            Get-ChildItem -Recurse .picoquic-build\*picoquic*.lib
          }

          # Check picotls libraries
          $PicotlsDir = ".picoquic-build\_deps\picotls-build"
          foreach ($lib in @("picotls-core", "picotls-minicrypto", "picotls-openssl")) {
            $LibPath = "$PicotlsDir\$lib.lib"
            if (Test-Path $LibPath) {
              Write-Host "âœ“ Found: $LibPath"
            } else {
              Write-Host "âœ— NOT FOUND: $lib.lib"
            }
          }

          Write-Host ""
          Write-Host "=== All .lib files in build directory ==="
          Get-ChildItem -Recurse .picoquic-build\*.lib

      - name: Build client
        shell: pwsh
        env:
          OPENSSL_DIR: C:\vcpkg\installed\x64-windows-static
          OPENSSL_STATIC: "1"
          VCPKG_ROOT: C:\vcpkg
          VCPKGRS_DYNAMIC: "0"
          RUSTFLAGS: -C target-feature=+crt-static
          PICOQUIC_AUTO_BUILD: "0"
          PICOQUIC_BUILD_DIR: ${{ github.workspace }}\.picoquic-build
          PICOTLS_INCLUDE_DIR: C:\tmp\picotls-build\picotls\include
        run: |
          $env:PICOQUIC_DIR = "$PWD\vendor\picoquic"

          Write-Host "Building client..."
          cargo build --release --target x86_64-pc-windows-msvc -p slipstream-client

          Write-Host "âœ… Client built"

      - name: Create release package
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path release\slipstream-client
          Copy-Item "target\x86_64-pc-windows-msvc\release\slipstream-client.exe" "release\slipstream-client\"
          
          @'
          # Slipstream Client Configuration
          DOMAIN=tunnel.example.com
          RESOLVER=YOUR_SERVER_IP:53
          TCP_LISTEN_PORT=7000
          CONGESTION_CONTROL=dcubic
          '@ | Out-File -FilePath "release\slipstream-client\client.conf" -Encoding UTF8
          
          @'
          @echo off
          setlocal EnableDelayedExpansion
          
          title Slipstream Client
          
          if not exist client.conf (
              echo Error: client.conf not found
              pause
              exit /b 1
          )
          
          for /f "tokens=1,2 delims==" %%a in (client.conf) do (
              set "line=%%a"
              if not "!line:~0,1!"=="#" if not "%%a"=="" set "%%a=%%b"
          )
          
          if "%RESOLVER%"=="YOUR_SERVER_IP:53" (
              echo Error: Configure RESOLVER in client.conf
              pause
              exit /b 1
          )
          
          echo Starting Slipstream Client...
          echo Domain: %DOMAIN%
          echo Resolver: %RESOLVER%
          echo Port: %TCP_LISTEN_PORT%
          echo.
          
          slipstream-client.exe --domain %DOMAIN% --resolver %RESOLVER% --tcp-listen-port %TCP_LISTEN_PORT% --congestion-control %CONGESTION_CONTROL%
          '@ | Out-File -FilePath "release\slipstream-client\start-client.bat" -Encoding ASCII
          
          @'
          # Slipstream Client - Windows x64 (Fully Static)
          
          âœ… **Zero dependencies - No VC++ Redistributable needed**
          
          ## Quick Start
          
          1. Edit `client.conf` - Set RESOLVER to your server IP
          2. Run `start-client.bat`
          3. Connect apps to SOCKS5: `127.0.0.1:7000`
          
          ## Requirements
          
          **NOTHING!** Fully static binary.
          
          Works on: Windows 10/11 x64
          
          ## Testing
          
          ```cmd
          curl --proxy socks5://127.0.0.1:7000 http://example.com
          ```
          
          ## Documentation
          
          https://github.com/Mygod/slipstream-rust
          '@ | Out-File -FilePath "release\slipstream-client\README.md" -Encoding UTF8
          
          Compress-Archive -Path "release\slipstream-client" -DestinationPath "release\slipstream-client-windows-x64-static.zip"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: slipstream-client-windows-x64-static
          path: release/*.zip

  create-release:
    name: Create GitHub Release
    needs: [build-linux, build-linux-client, build-windows]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            artifacts/**/*.tar.gz
            artifacts/**/*.zip
          generate_release_notes: true
          body: |
            ## ğŸš€ Standalone Executables - Zero Dependencies

            ### Linux Server
            - **File**: `slipstream-server-linux-x64-static.tar.gz`
            - **Static MUSL binary** - works on ANY x86_64 Linux
            - **No dependencies** required to run

            ### Linux Client
            - **File**: `slipstream-client-linux-x64-static.tar.gz`
            - **Static MUSL binary** - works on ANY x86_64 Linux
            - **No dependencies** required to run

            ### Windows Client
            - **File**: `slipstream-client-windows-x64-static.zip`
            - **Static binary** - no VC++ Redistributable needed
            - **No dependencies** required to run

            ### Quick Start
            1. Download and extract
            2. Edit configuration file
            3. Run startup script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
