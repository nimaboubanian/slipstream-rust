name: Build Standalone Release Executables

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build-linux:
    name: Build Linux Server (Static)
    runs-on: ubuntu-latest
    container:
      image: rust:alpine
    
    steps:
      - name: Install build dependencies
        run: |
          echo "https://dl-cdn.alpinelinux.org/alpine/edge/main" >> /etc/apk/repositories
          echo "https://dl-cdn.alpinelinux.org/alpine/edge/community" >> /etc/apk/repositories
          
          apk update
          apk add --no-cache \
            git \
            cmake \
            make \
            gcc \
            g++ \
            musl-dev \
            linux-headers \
            openssl-dev \
            openssl-libs-static \
            pkgconfig \
            bash \
            perl \
            file \
            binutils

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Pre-fetch and patch picotls
        run: |
          echo "Pre-fetching and building picotls..."

          # Clone picotls with submodules (includes picotest)
          mkdir -p /tmp/picotls-build
          git clone --depth 1 --recurse-submodules https://github.com/h2o/picotls.git /tmp/picotls-build/picotls

          # Patch the CMakeLists.txt to allow CMake 3.5
          cd /tmp/picotls-build/picotls
          sed -i 's/CMAKE_MINIMUM_REQUIRED(VERSION [0-9.]*)/CMAKE_MINIMUM_REQUIRED(VERSION 3.5)/' CMakeLists.txt

          echo "âœ… Cloned picotls with submodules"
          head -n 5 CMakeLists.txt

          # Build picotls libraries only (skip test targets)
          mkdir -p /tmp/picotls-build/picotls-build
          cmake -S /tmp/picotls-build/picotls -B /tmp/picotls-build/picotls-build \
            -DCMAKE_BUILD_TYPE=Release \
            -DOPENSSL_ROOT_DIR=/usr \
            -DOPENSSL_LIBRARIES=/usr/lib

          # Build only the library targets, not tests
          cmake --build /tmp/picotls-build/picotls-build --target picotls-core picotls-minicrypto picotls-openssl

          echo "âœ… Built picotls libraries"
          ls -la /tmp/picotls-build/picotls-build/*.a

      - name: Build picoquic
        run: |
          ROOT_DIR="$PWD"
          PICOQUIC_DIR="${ROOT_DIR}/vendor/picoquic"
          BUILD_DIR="${ROOT_DIR}/.picoquic-build"
          PICOQUIC_PATCHED_PTLS="/tmp/picotls-build"
          PICOQUIC_PATCHED_PTLS_BUILD="/tmp/picotls-build/picotls-build"

          echo "Building picoquic..."

          # Configure with the pre-built picotls
          cmake -S "${PICOQUIC_DIR}" -B "${BUILD_DIR}" \
            -DCMAKE_BUILD_TYPE=Release \
            -DPICOQUIC_FETCH_PTLS=OFF \
            -DPTLS_INCLUDE_DIR="${PICOQUIC_PATCHED_PTLS}/picotls/include" \
            -DPTLS_CORE_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-core.a" \
            -DPTLS_OPENSSL_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-openssl.a" \
            -DPTLS_MINICRYPTO_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-minicrypto.a"

          # Build picoquic
          cmake --build "${BUILD_DIR}"

          echo "âœ… Picoquic built successfully"

          # Debug: List what was actually created
          echo ""
          echo "=== Picoquic build directory contents ==="
          ls -la "${BUILD_DIR}/"
          echo ""
          echo "=== Picoquic library files (.a) ==="
          find "${BUILD_DIR}" -name "*.a" | sort
          echo ""
          echo "=== Picoquic subdirectories ==="
          find "${BUILD_DIR}" -type d | head -20

      - name: Copy picotls libraries for Rust build
        run: |
          # The Rust build script expects picotls libs in _deps/picotls-build
          mkdir -p .picoquic-build/_deps/picotls-build

          # Copy picotls libraries and report what was found
          echo "Copying picotls libraries..."
          for lib in /tmp/picotls-build/picotls-build/libpicotls-*.a; do
            if [ -f "$lib" ]; then
              cp "$lib" .picoquic-build/_deps/picotls-build/
              echo "âœ“ Copied: $(basename $lib)"
            fi
          done

          # Check for picotls-fusion (may not exist on all platforms)
          if [ -f "/tmp/picotls-build/picotls-build/libpicotls-fusion.a" ]; then
            echo "âœ“ picotls-fusion available"
          else
            echo "âš  picotls-fusion not available (CPU feature dependent)"
          fi

          echo ""
          echo "=== Copied picotls libraries ==="
          ls -la .picoquic-build/_deps/picotls-build/
          echo ""
          echo "=== All picoquic build files ==="
          find .picoquic-build -name "*.a" | sort

      - name: Set environment for static build
        run: |
          echo "OPENSSL_STATIC=1" >> $GITHUB_ENV
          echo "OPENSSL_LIB_DIR=/usr/lib" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=/usr/include" >> $GITHUB_ENV
          echo "PICOQUIC_AUTO_BUILD=0" >> $GITHUB_ENV
          echo "PICOQUIC_BUILD_DIR=$PWD/.picoquic-build" >> $GITHUB_ENV
          echo "PICOTLS_INCLUDE_DIR=/tmp/picotls-build/picotls/include" >> $GITHUB_ENV

      - name: Verify libraries before Rust build
        run: |
          echo "=== Verifying required libraries ==="

          # Check picoquic library
          if [ -f ".picoquic-build/libpicoquic-core.a" ]; then
            echo "âœ“ Found: .picoquic-build/libpicoquic-core.a"
          elif [ -f ".picoquic-build/libpicoquic_core.a" ]; then
            echo "âœ“ Found: .picoquic-build/libpicoquic_core.a"
          elif [ -f ".picoquic-build/picoquic/libpicoquic-core.a" ]; then
            echo "âœ“ Found: .picoquic-build/picoquic/libpicoquic-core.a"
          else
            echo "âœ— NOT FOUND: libpicoquic-core.a"
            echo "Searching for picoquic libraries:"
            find .picoquic-build -name "*picoquic*" 2>/dev/null || true
          fi

          # Check picotls libraries
          for lib in picotls-core picotls-minicrypto picotls-openssl; do
            if [ -f ".picoquic-build/_deps/picotls-build/lib$lib.a" ]; then
              echo "âœ“ Found: .picoquic-build/_deps/picotls-build/lib$lib.a"
            else
              echo "âœ— NOT FOUND: lib$lib.a"
            fi
          done

          echo ""
          echo "=== All .a files in build directory ==="
          find .picoquic-build -name "*.a" | sort

      - name: Build server
        run: |
          echo "Building slipstream-server..."
          cargo build --release --target x86_64-unknown-linux-musl -p slipstream-server
          echo "âœ… Server built successfully"

      - name: Verify static linking
        run: |
          BINARY="target/x86_64-unknown-linux-musl/release/slipstream-server"
          
          echo "=== Binary information ==="
          file "$BINARY"
          
          echo ""
          echo "=== File size (before strip) ==="
          ls -lh "$BINARY"
          
          echo ""
          echo "=== Checking dynamic dependencies ==="
          if ldd "$BINARY" 2>&1 | grep -q "not a dynamic executable"; then
            echo "âœ… SUCCESS: Fully static binary!"
          else
            echo "âš ï¸  Dynamic dependencies:"
            ldd "$BINARY" || true
          fi
          
          echo ""
          echo "=== Stripping debug symbols ==="
          strip "$BINARY"
          echo "Final size:"
          ls -lh "$BINARY"

      - name: Create release package
        run: |
          mkdir -p release/slipstream-server
          cp target/x86_64-unknown-linux-musl/release/slipstream-server release/slipstream-server/
          
          cat > release/slipstream-server/server.conf << 'EOF'
          # Slipstream Server Configuration
          DOMAIN=tunnel.example.com
          DNS_LISTEN_PORT=53
          TARGET_ADDRESS=127.0.0.1:5201
          CERT_PATH=./cert.pem
          KEY_PATH=./key.pem
          EOF
          
          cat > release/slipstream-server/start-server.sh << 'EOF'
          #!/bin/bash
          set -e
          
          if [ ! -f server.conf ]; then
              echo "âŒ Error: server.conf not found"
              exit 1
          fi
          
          source server.conf
          
          echo "================================================"
          echo "  Slipstream DNS Tunnel Server"
          echo "================================================"
          echo ""
          echo "Configuration:"
          echo "  Domain      : ${DOMAIN}"
          echo "  DNS Port    : ${DNS_LISTEN_PORT}"
          echo "  Target      : ${TARGET_ADDRESS}"
          echo "  Certificate : ${CERT_PATH}"
          echo "  Private Key : ${KEY_PATH}"
          echo ""
          
          if [ ! -f "${CERT_PATH}" ] || [ ! -f "${KEY_PATH}" ]; then
              echo "âŒ Error: Certificate files not found"
              echo "   Run: ./generate-cert.sh"
              exit 1
          fi
          
          echo "Starting server..."
          echo "Press Ctrl+C to stop"
          echo ""
          
          ./slipstream-server \
            --dns-listen-port ${DNS_LISTEN_PORT} \
            --target-address ${TARGET_ADDRESS} \
            --domain ${DOMAIN} \
            --cert ${CERT_PATH} \
            --key ${KEY_PATH}
          EOF
          chmod +x release/slipstream-server/start-server.sh
          
          cat > release/slipstream-server/generate-cert.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "Generating self-signed TLS certificate..."
          echo ""
          
          if ! command -v openssl &> /dev/null; then
              echo "âŒ Error: openssl command not found"
              echo ""
              echo "Install OpenSSL:"
              echo "  Ubuntu/Debian: sudo apt-get install openssl"
              echo "  CentOS/RHEL:   sudo yum install openssl"
              echo "  Alpine:        apk add openssl"
              exit 1
          fi
          
          openssl req -x509 -newkey rsa:2048 -nodes \
            -keyout key.pem -out cert.pem -days 365 \
            -subj "/CN=slipstream" \
            -addext "subjectAltName=DNS:tunnel.example.com,DNS:*.tunnel.example.com"
          
          chmod 600 key.pem
          chmod 644 cert.pem
          
          echo ""
          echo "âœ… Certificate generated: cert.pem, key.pem"
          EOF
          chmod +x release/slipstream-server/generate-cert.sh
          
          cat > release/slipstream-server/README.md << 'EOF'
          # Slipstream Server - Linux x86_64 (Fully Static)
          
          âœ… **Zero runtime dependencies - Works on ANY x86_64 Linux**
          
          ## Quick Start
          
          ```bash
          # 1. Generate certificates
          ./generate-cert.sh
          
          # 2. Configure (edit server.conf)
          nano server.conf
          
          # 3. Run (port 53 requires root)
          sudo ./start-server.sh
          ```
          
          ## Requirements
          
          **To run the server**: NOTHING (fully static binary)
          
          **To generate certificates** (one-time): `openssl` command
          ```bash
          sudo apt install openssl  # Ubuntu/Debian
          sudo yum install openssl  # CentOS/RHEL
          apk add openssl          # Alpine
          ```
          
          ## Configuration
          
          Edit `server.conf`:
          - `DOMAIN`: Your tunnel domain (e.g., tunnel.example.com)
          - `DNS_LISTEN_PORT`: 53 (production) or 8853 (testing)
          - `TARGET_ADDRESS`: Forwarding destination (e.g., 127.0.0.1:5201)
          
          ## Firewall
          
          ```bash
          # Ubuntu/Debian
          sudo ufw allow 53/udp
          
          # CentOS/RHEL/Fedora
          sudo firewall-cmd --permanent --add-port=53/udp
          sudo firewall-cmd --reload
          ```
          
          ## Testing
          
          ```bash
          # Check if listening
          sudo netstat -ulnp | grep 53
          
          # Test DNS
          dig @localhost -p 53 test.tunnel.example.com
          ```
          
          ## Documentation
          
          https://github.com/Mygod/slipstream-rust
          EOF
          
          cd release
          tar -czf slipstream-server-linux-x64-static.tar.gz slipstream-server/
          
          echo ""
          echo "=== Package created ==="
          ls -lh *.tar.gz

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: slipstream-server-linux-x64-static
          path: release/*.tar.gz

  build-linux-client:
    name: Build Linux Client (Static)
    runs-on: ubuntu-latest
    container:
      image: rust:alpine

    steps:
      - name: Install build dependencies
        run: |
          echo "https://dl-cdn.alpinelinux.org/alpine/edge/main" >> /etc/apk/repositories
          echo "https://dl-cdn.alpinelinux.org/alpine/edge/community" >> /etc/apk/repositories

          apk update
          apk add --no-cache \
            git \
            cmake \
            make \
            gcc \
            g++ \
            musl-dev \
            linux-headers \
            openssl-dev \
            openssl-libs-static \
            pkgconfig \
            bash \
            perl \
            file \
            binutils

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Pre-fetch and patch picotls
        run: |
          echo "Pre-fetching and building picotls..."

          # Clone picotls with submodules (includes picotest)
          mkdir -p /tmp/picotls-build
          git clone --depth 1 --recurse-submodules https://github.com/h2o/picotls.git /tmp/picotls-build/picotls

          # Patch the CMakeLists.txt to allow CMake 3.5
          cd /tmp/picotls-build/picotls
          sed -i 's/CMAKE_MINIMUM_REQUIRED(VERSION [0-9.]*)/CMAKE_MINIMUM_REQUIRED(VERSION 3.5)/' CMakeLists.txt

          echo "âœ… Cloned picotls with submodules"
          head -n 5 CMakeLists.txt

          # Build picotls libraries only (skip test targets)
          mkdir -p /tmp/picotls-build/picotls-build
          cmake -S /tmp/picotls-build/picotls -B /tmp/picotls-build/picotls-build \
            -DCMAKE_BUILD_TYPE=Release \
            -DOPENSSL_ROOT_DIR=/usr \
            -DOPENSSL_LIBRARIES=/usr/lib

          # Build only the library targets, not tests
          cmake --build /tmp/picotls-build/picotls-build --target picotls-core picotls-minicrypto picotls-openssl

          echo "âœ… Built picotls libraries"
          ls -la /tmp/picotls-build/picotls-build/*.a

      - name: Build picoquic
        run: |
          ROOT_DIR="$PWD"
          PICOQUIC_DIR="${ROOT_DIR}/vendor/picoquic"
          BUILD_DIR="${ROOT_DIR}/.picoquic-build"
          PICOQUIC_PATCHED_PTLS="/tmp/picotls-build"
          PICOQUIC_PATCHED_PTLS_BUILD="/tmp/picotls-build/picotls-build"

          echo "Building picoquic..."

          # Configure with the pre-built picotls
          cmake -S "${PICOQUIC_DIR}" -B "${BUILD_DIR}" \
            -DCMAKE_BUILD_TYPE=Release \
            -DPICOQUIC_FETCH_PTLS=OFF \
            -DPTLS_INCLUDE_DIR="${PICOQUIC_PATCHED_PTLS}/picotls/include" \
            -DPTLS_CORE_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-core.a" \
            -DPTLS_OPENSSL_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-openssl.a" \
            -DPTLS_MINICRYPTO_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-minicrypto.a"

          # Build picoquic
          cmake --build "${BUILD_DIR}"

          echo "âœ… Picoquic built successfully"

          # Debug: List what was actually created
          echo ""
          echo "=== Picoquic build directory contents ==="
          ls -la "${BUILD_DIR}/"
          echo ""
          echo "=== Picoquic library files (.a) ==="
          find "${BUILD_DIR}" -name "*.a" | sort
          echo ""
          echo "=== Picoquic subdirectories ==="
          find "${BUILD_DIR}" -type d | head -20

      - name: Copy picotls libraries for Rust build
        run: |
          # The Rust build script expects picotls libs in _deps/picotls-build
          mkdir -p .picoquic-build/_deps/picotls-build

          # Copy picotls libraries and report what was found
          echo "Copying picotls libraries..."
          for lib in /tmp/picotls-build/picotls-build/libpicotls-*.a; do
            if [ -f "$lib" ]; then
              cp "$lib" .picoquic-build/_deps/picotls-build/
              echo "âœ“ Copied: $(basename $lib)"
            fi
          done

          # Check for picotls-fusion (may not exist on all platforms)
          if [ -f "/tmp/picotls-build/picotls-build/libpicotls-fusion.a" ]; then
            echo "âœ“ picotls-fusion available"
          else
            echo "âš  picotls-fusion not available (CPU feature dependent)"
          fi

          echo ""
          echo "=== Copied picotls libraries ==="
          ls -la .picoquic-build/_deps/picotls-build/
          echo ""
          echo "=== All picoquic build files ==="
          find .picoquic-build -name "*.a" | sort

      - name: Set environment for static build
        run: |
          echo "OPENSSL_STATIC=1" >> $GITHUB_ENV
          echo "OPENSSL_LIB_DIR=/usr/lib" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=/usr/include" >> $GITHUB_ENV
          echo "PICOQUIC_AUTO_BUILD=0" >> $GITHUB_ENV
          echo "PICOQUIC_BUILD_DIR=$PWD/.picoquic-build" >> $GITHUB_ENV
          echo "PICOTLS_INCLUDE_DIR=/tmp/picotls-build/picotls/include" >> $GITHUB_ENV

      - name: Verify libraries before Rust build
        run: |
          echo "=== Verifying required libraries ==="

          # Check picoquic library
          if [ -f ".picoquic-build/libpicoquic-core.a" ]; then
            echo "âœ“ Found: .picoquic-build/libpicoquic-core.a"
          elif [ -f ".picoquic-build/libpicoquic_core.a" ]; then
            echo "âœ“ Found: .picoquic-build/libpicoquic_core.a"
          elif [ -f ".picoquic-build/picoquic/libpicoquic-core.a" ]; then
            echo "âœ“ Found: .picoquic-build/picoquic/libpicoquic-core.a"
          else
            echo "âœ— NOT FOUND: libpicoquic-core.a"
            echo "Searching for picoquic libraries:"
            find .picoquic-build -name "*picoquic*" 2>/dev/null || true
          fi

          # Check picotls libraries
          for lib in picotls-core picotls-minicrypto picotls-openssl; do
            if [ -f ".picoquic-build/_deps/picotls-build/lib$lib.a" ]; then
              echo "âœ“ Found: .picoquic-build/_deps/picotls-build/lib$lib.a"
            else
              echo "âœ— NOT FOUND: lib$lib.a"
            fi
          done

          echo ""
          echo "=== All .a files in build directory ==="
          find .picoquic-build -name "*.a" | sort

      - name: Build client
        run: |
          echo "Building slipstream-client..."
          cargo build --release --target x86_64-unknown-linux-musl -p slipstream-client
          echo "âœ… Client built successfully"

      - name: Verify static linking
        run: |
          BINARY="target/x86_64-unknown-linux-musl/release/slipstream-client"

          echo "=== Binary information ==="
          file "$BINARY"

          echo ""
          echo "=== File size (before strip) ==="
          ls -lh "$BINARY"

          echo ""
          echo "=== Checking dynamic dependencies ==="
          if ldd "$BINARY" 2>&1 | grep -q "not a dynamic executable"; then
            echo "âœ… SUCCESS: Fully static binary!"
          else
            echo "âš ï¸  Dynamic dependencies:"
            ldd "$BINARY" || true
          fi

          echo ""
          echo "=== Stripping debug symbols ==="
          strip "$BINARY"
          echo "Final size:"
          ls -lh "$BINARY"

      - name: Create release package
        run: |
          mkdir -p release/slipstream-client
          cp target/x86_64-unknown-linux-musl/release/slipstream-client release/slipstream-client/

          cat > release/slipstream-client/client.conf << 'EOF'
          # Slipstream Client Configuration
          DOMAIN=tunnel.example.com
          RESOLVER=YOUR_SERVER_IP:53
          TCP_LISTEN_PORT=7000
          CONGESTION_CONTROL=dcubic
          EOF

          cat > release/slipstream-client/start-client.sh << 'EOF'
          #!/bin/bash
          set -e

          if [ ! -f client.conf ]; then
              echo "âŒ Error: client.conf not found"
              exit 1
          fi

          source client.conf

          if [ "$RESOLVER" = "YOUR_SERVER_IP:53" ]; then
              echo "âŒ Error: Configure RESOLVER in client.conf"
              exit 1
          fi

          echo "================================================"
          echo "  Slipstream DNS Tunnel Client"
          echo "================================================"
          echo ""
          echo "Configuration:"
          echo "  Domain      : ${DOMAIN}"
          echo "  Resolver    : ${RESOLVER}"
          echo "  Listen Port : ${TCP_LISTEN_PORT}"
          echo ""

          echo "Starting client..."
          echo "Press Ctrl+C to stop"
          echo ""

          ./slipstream-client \
            --domain ${DOMAIN} \
            --resolver ${RESOLVER} \
            --tcp-listen-port ${TCP_LISTEN_PORT} \
            --congestion-control ${CONGESTION_CONTROL}
          EOF
          chmod +x release/slipstream-client/start-client.sh

          cat > release/slipstream-client/README.md << 'EOF'
          # Slipstream Client - Linux x86_64 (Fully Static)

          âœ… **Zero runtime dependencies - Works on ANY x86_64 Linux**

          ## Quick Start

          ```bash
          # 1. Configure (edit client.conf)
          nano client.conf

          # 2. Run
          ./start-client.sh

          # 3. Use SOCKS5 proxy
          curl --proxy socks5://127.0.0.1:7000 http://example.com
          ```

          ## Requirements

          **To run the client**: NOTHING (fully static binary)

          Works on: Any x86_64 Linux distribution (Ubuntu, Debian, CentOS, Alpine, etc.)

          ## Configuration

          Edit `client.conf`:
          - `DOMAIN`: Your tunnel domain (e.g., tunnel.example.com)
          - `RESOLVER`: DNS server IP (your server's IP)
          - `TCP_LISTEN_PORT`: Local SOCKS5 proxy port (default: 7000)
          - `CONGESTION_CONTROL`: Congestion algorithm (dcubic, bbr, cubic)

          ## Testing

          ```bash
          # Test SOCKS5 proxy
          curl --proxy socks5://127.0.0.1:7000 http://example.com

          # Test with SSH
          ssh -o ProxyCommand="nc -X 5 -x 127.0.0.1:7000 %h %p" user@remote
          ```

          ## Documentation

          https://github.com/Mygod/slipstream-rust
          EOF

          cd release
          tar -czf slipstream-client-linux-x64-static.tar.gz slipstream-client/

          echo ""
          echo "=== Package created ==="
          ls -lh *.tar.gz

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: slipstream-client-linux-x64-static
          path: release/*.tar.gz

  build-linux-server-aarch64:
    name: Build Linux Server ARM64 (Static)
    runs-on: ubuntu-latest

    steps:
      - name: Install build dependencies
        run: |
          sudo dpkg --add-architecture arm64

          # Add Ubuntu ports repository for arm64 packages
          sudo tee /etc/apt/sources.list.d/ubuntu-arm64.list > /dev/null << 'EOF'
          deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ noble main restricted universe multiverse
          deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ noble-updates main restricted universe multiverse
          deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ noble-security main restricted universe multiverse
          EOF

          # Update and ignore errors from default repos that don't have arm64
          sudo apt-get update -o Acquire::Retries=3 || true

          # Verify we can access arm64 packages
          apt-cache show libc6:arm64 >/dev/null || exit 1

          sudo apt-get install -y \
            git \
            cmake \
            make \
            gcc \
            g++ \
            musl-dev \
            musl-tools \
            linux-libc-dev:arm64 \
            libssl-dev:arm64 \
            libc6-dev:arm64 \
            pkg-config \
            bash \
            perl \
            file \
            binutils \
            gcc-aarch64-linux-gnu \
            g++-aarch64-linux-gnu \
            qemu-user-static

      - name: Install Rust toolchain
        run: |
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          rustup target add aarch64-unknown-linux-gnu

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Build OpenSSL for aarch64
        run: |
          echo "Building OpenSSL for aarch64 cross-compilation..."

          mkdir -p /tmp/openssl-build
          cd /tmp/openssl-build

          # Download OpenSSL 3.0.x (stable LTS)
          curl -fsSL https://www.openssl.org/source/openssl-3.0.15.tar.gz -o openssl.tar.gz
          tar -xzf openssl.tar.gz
          cd openssl-3.0.15

          # Configure for cross-compilation to aarch64
          # Build static libraries with all standard features
          ./Configure \
            --prefix=/tmp/openssl-aarch64 \
            --cross-compile-prefix=aarch64-linux-gnu- \
            linux-aarch64 \
            no-shared \
            no-sock \
            no-srtp

          # Build libraries
          make -j$(nproc)

          # Install only the libraries and headers
          make install_sw

          echo "âœ… OpenSSL built for aarch64"
          ls -la /tmp/openssl-aarch64/lib/
          ls -la /tmp/openssl-aarch64/include/openssl/ | head -20

      - name: Pre-fetch and patch picotls (aarch64)
        run: |
          echo "Pre-fetching and building picotls for aarch64..."

          # Clone picotls with submodules (includes picotest)
          mkdir -p /tmp/picotls-build
          git clone --depth 1 --recurse-submodules https://github.com/h2o/picotls.git /tmp/picotls-build/picotls

          # Patch the CMakeLists.txt to allow CMake 3.5
          cd /tmp/picotls-build/picotls
          sed -i 's/CMAKE_MINIMUM_REQUIRED(VERSION [0-9.]*)/CMAKE_MINIMUM_REQUIRED(VERSION 3.5)/' CMakeLists.txt

          echo "âœ… Cloned picotls with submodules"

          # Build picotls libraries for aarch64 using our built OpenSSL
          mkdir -p /tmp/picotls-build/picotls-build
          cmake -S /tmp/picotls-build/picotls -B /tmp/picotls-build/picotls-build \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_SYSTEM_NAME=Linux \
            -DCMAKE_SYSTEM_PROCESSOR=aarch64 \
            -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc \
            -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++ \
            -DCMAKE_AR=/usr/bin/aarch64-linux-gnu-gcc-ar \
            -DCMAKE_RANLIB=/usr/bin/aarch64-linux-gnu-gcc-ranlib \
            -DCMAKE_FIND_ROOT_PATH=/tmp/openssl-aarch64\;/usr/aarch64-linux-gnu \
            -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
            -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
            -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
            -DOPENSSL_ROOT_DIR=/tmp/openssl-aarch64 \
            -DOPENSSL_INCLUDE_DIR=/tmp/openssl-aarch64/include \
            -DOPENSSL_CRYPTO_LIBRARY=/tmp/openssl-aarch64/lib/libcrypto.a \
            -DOPENSSL_SSL_LIBRARY=/tmp/openssl-aarch64/lib/libssl.a

          # Build only the library targets, not tests
          cmake --build /tmp/picotls-build/picotls-build --target picotls-core picotls-minicrypto picotls-openssl

          echo "âœ… Built picotls libraries for aarch64"
          ls -la /tmp/picotls-build/picotls-build/*.a

      - name: Build picoquic (aarch64)
        run: |
          ROOT_DIR="$PWD"
          PICOQUIC_DIR="${ROOT_DIR}/vendor/picoquic"
          BUILD_DIR="${ROOT_DIR}/.picoquic-build"
          PICOQUIC_PATCHED_PTLS="/tmp/picotls-build"
          PICOQUIC_PATCHED_PTLS_BUILD="/tmp/picotls-build/picotls-build"

          echo "Building picoquic for aarch64..."

          # Configure with the pre-built picotls for aarch64
          cmake -S "${PICOQUIC_DIR}" -B "${BUILD_DIR}" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_SYSTEM_NAME=Linux \
            -DCMAKE_SYSTEM_PROCESSOR=aarch64 \
            -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc \
            -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++ \
            -DCMAKE_AR=/usr/bin/aarch64-linux-gnu-gcc-ar \
            -DCMAKE_RANLIB=/usr/bin/aarch64-linux-gnu-gcc-ranlib \
            -DCMAKE_FIND_ROOT_PATH=/tmp/openssl-aarch64\;/usr/aarch64-linux-gnu \
            -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
            -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
            -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
            -DOPENSSL_ROOT_DIR=/tmp/openssl-aarch64 \
            -DOPENSSL_INCLUDE_DIR=/tmp/openssl-aarch64/include \
            -DOPENSSL_CRYPTO_LIBRARY=/tmp/openssl-aarch64/lib/libcrypto.a \
            -DOPENSSL_SSL_LIBRARY=/tmp/openssl-aarch64/lib/libssl.a \
            -DPICOQUIC_FETCH_PTLS=OFF \
            -DPTLS_INCLUDE_DIR="${PICOQUIC_PATCHED_PTLS}/picotls/include" \
            -DPTLS_CORE_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-core.a" \
            -DPTLS_OPENSSL_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-openssl.a" \
            -DPTLS_MINICRYPTO_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-minicrypto.a"

          # Build picoquic
          cmake --build "${BUILD_DIR}"

          echo "âœ… Picoquic built successfully for aarch64"

          echo ""
          echo "=== Picoquic library files (.a) ==="
          find "${BUILD_DIR}" -name "*.a" | sort

      - name: Copy picotls libraries for Rust build
        run: |
          # The Rust build script expects picotls libs in _deps/picotls-build
          mkdir -p .picoquic-build/_deps/picotls-build

          # Copy picotls libraries
          echo "Copying picotls libraries..."
          for lib in /tmp/picotls-build/picotls-build/libpicotls-*.a; do
            if [ -f "$lib" ]; then
              cp "$lib" .picoquic-build/_deps/picotls-build/
              echo "âœ“ Copied: $(basename $lib)"
            fi
          done

          echo ""
          echo "=== Copied picotls libraries ==="
          ls -la .picoquic-build/_deps/picotls-build/

      - name: Set environment for static build
        run: |
          echo "OPENSSL_DIR=/tmp/openssl-aarch64" >> $GITHUB_ENV
          echo "OPENSSL_LIB_DIR=/tmp/openssl-aarch64/lib" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=/tmp/openssl-aarch64/include" >> $GITHUB_ENV
          echo "OPENSSL_STATIC=1" >> $GITHUB_ENV
          echo "PICOQUIC_AUTO_BUILD=0" >> $GITHUB_ENV
          echo "PICOQUIC_BUILD_DIR=$PWD/.picoquic-build" >> $GITHUB_ENV
          echo "PICOTLS_INCLUDE_DIR=/tmp/picotls-build/picotls/include" >> $GITHUB_ENV
          echo "CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc" >> $GITHUB_ENV
          echo "AR_aarch64_unknown_linux_gnu=aarch64-linux-gnu-ar" >> $GITHUB_ENV
          echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV

      - name: Build server (aarch64)
        run: |
          echo "Building slipstream-server for aarch64..."
          cargo build --release --target aarch64-unknown-linux-gnu -p slipstream-server
          echo "âœ… Server built successfully"

      - name: Verify static linking
        run: |
          BINARY="target/aarch64-unknown-linux-gnu/release/slipstream-server"

          echo "=== Binary information ==="
          file "$BINARY"

          echo ""
          echo "=== File size (before strip) ==="
          ls -lh "$BINARY"

          echo ""
          echo "=== Stripping debug symbols ==="
          aarch64-linux-gnu-strip "$BINARY"
          echo "Final size:"
          ls -lh "$BINARY"

      - name: Create release package
        run: |
          mkdir -p release/slipstream-server
          cp target/aarch64-unknown-linux-gnu/release/slipstream-server release/slipstream-server/

          cat > release/slipstream-server/server.conf << 'EOF'
          # Slipstream Server Configuration
          DOMAIN=tunnel.example.com
          DNS_LISTEN_PORT=53
          TARGET_ADDRESS=127.0.0.1:5201
          CERT_PATH=./cert.pem
          KEY_PATH=./key.pem
          EOF

          cat > release/slipstream-server/start-server.sh << 'EOF'
          #!/bin/bash
          set -e

          if [ ! -f server.conf ]; then
              echo "âŒ Error: server.conf not found"
              exit 1
          fi

          source server.conf

          echo "================================================"
          echo "  Slipstream DNS Tunnel Server (ARM64)"
          echo "================================================"
          echo ""
          echo "Configuration:"
          echo "  Domain      : ${DOMAIN}"
          echo "  DNS Port    : ${DNS_LISTEN_PORT}"
          echo "  Target      : ${TARGET_ADDRESS}"
          echo "  Certificate : ${CERT_PATH}"
          echo "  Private Key : ${KEY_PATH}"
          echo ""

          if [ ! -f "${CERT_PATH}" ] || [ ! -f "${KEY_PATH}" ]; then
              echo "âŒ Error: Certificate files not found"
              echo "   Run: ./generate-cert.sh"
              exit 1
          fi

          echo "Starting server..."
          echo "Press Ctrl+C to stop"
          echo ""

          ./slipstream-server \
            --dns-listen-port ${DNS_LISTEN_PORT} \
            --target-address ${TARGET_ADDRESS} \
            --domain ${DOMAIN} \
            --cert ${CERT_PATH} \
            --key ${KEY_PATH}
          EOF
          chmod +x release/slipstream-server/start-server.sh

          cat > release/slipstream-server/generate-cert.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "Generating self-signed TLS certificate..."
          echo ""

          if ! command -v openssl &> /dev/null; then
              echo "âŒ Error: openssl command not found"
              exit 1
          fi

          openssl req -x509 -newkey rsa:2048 -nodes \
            -keyout key.pem -out cert.pem -days 365 \
            -subj "/CN=slipstream" \
            -addext "subjectAltName=DNS:tunnel.example.com,DNS:*.tunnel.example.com"

          chmod 600 key.pem
          chmod 644 cert.pem

          echo ""
          echo "âœ… Certificate generated: cert.pem, key.pem"
          EOF
          chmod +x release/slipstream-server/generate-cert.sh

          cat > release/slipstream-server/README.md << 'EOF'
          # Slipstream Server - Linux ARM64 (Fully Static)

          âœ… **Zero runtime dependencies - Works on ANY ARM64 Linux**

          ## Quick Start

          ```bash
          # 1. Generate certificates
          ./generate-cert.sh

          # 2. Configure (edit server.conf)
          nano server.conf

          # 3. Run (port 53 requires root)
          sudo ./start-server.sh
          ```

          ## Requirements

          **To run the server**: NOTHING (fully static binary)

          **To generate certificates** (one-time): `openssl` command

          ## Configuration

          Edit `server.conf`:
          - `DOMAIN`: Your tunnel domain (e.g., tunnel.example.com)
          - `DNS_LISTEN_PORT`: 53 (production) or 8853 (testing)
          - `TARGET_ADDRESS`: Forwarding destination (e.g., 127.0.0.1:5201)

          ## Documentation

          https://github.com/Mygod/slipstream-rust
          EOF

          cd release
          tar -czf slipstream-server-linux-aarch64-static.tar.gz slipstream-server/

          echo ""
          echo "=== Package created ==="
          ls -lh *.tar.gz

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: slipstream-server-linux-aarch64-static
          path: release/*.tar.gz

  build-linux-client-aarch64:
    name: Build Linux Client ARM64 (Static)
    runs-on: ubuntu-latest

    steps:
      - name: Install build dependencies
        run: |
          sudo dpkg --add-architecture arm64

          # Add Ubuntu ports repository for arm64 packages
          sudo tee /etc/apt/sources.list.d/ubuntu-arm64.list > /dev/null << 'EOF'
          deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ noble main restricted universe multiverse
          deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ noble-updates main restricted universe multiverse
          deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ noble-security main restricted universe multiverse
          EOF

          # Update and ignore errors from default repos that don't have arm64
          sudo apt-get update -o Acquire::Retries=3 || true

          # Verify we can access arm64 packages
          apt-cache show libc6:arm64 >/dev/null || exit 1

          sudo apt-get install -y \
            git \
            cmake \
            make \
            gcc \
            g++ \
            musl-dev \
            musl-tools \
            linux-libc-dev:arm64 \
            libssl-dev:arm64 \
            libc6-dev:arm64 \
            pkg-config \
            bash \
            perl \
            file \
            binutils \
            gcc-aarch64-linux-gnu \
            g++-aarch64-linux-gnu \
            qemu-user-static

      - name: Install Rust toolchain
        run: |
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          rustup target add aarch64-unknown-linux-gnu

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Build OpenSSL for aarch64
        run: |
          echo "Building OpenSSL for aarch64 cross-compilation..."

          mkdir -p /tmp/openssl-build
          cd /tmp/openssl-build

          # Download OpenSSL 3.0.x (stable LTS)
          curl -fsSL https://www.openssl.org/source/openssl-3.0.15.tar.gz -o openssl.tar.gz
          tar -xzf openssl.tar.gz
          cd openssl-3.0.15

          # Configure for cross-compilation to aarch64
          # Build static libraries with all standard features
          ./Configure \
            --prefix=/tmp/openssl-aarch64 \
            --cross-compile-prefix=aarch64-linux-gnu- \
            linux-aarch64 \
            no-shared \
            no-sock \
            no-srtp

          # Build libraries
          make -j$(nproc)

          # Install only the libraries and headers
          make install_sw

          echo "âœ… OpenSSL built for aarch64"
          ls -la /tmp/openssl-aarch64/lib/
          ls -la /tmp/openssl-aarch64/include/openssl/ | head -20

      - name: Pre-fetch and patch picotls (aarch64)
        run: |
          echo "Pre-fetching and building picotls for aarch64..."

          # Clone picotls with submodules (includes picotest)
          mkdir -p /tmp/picotls-build
          git clone --depth 1 --recurse-submodules https://github.com/h2o/picotls.git /tmp/picotls-build/picotls

          # Patch the CMakeLists.txt to allow CMake 3.5
          cd /tmp/picotls-build/picotls
          sed -i 's/CMAKE_MINIMUM_REQUIRED(VERSION [0-9.]*)/CMAKE_MINIMUM_REQUIRED(VERSION 3.5)/' CMakeLists.txt

          echo "âœ… Cloned picotls with submodules"

          # Build picotls libraries for aarch64 using our built OpenSSL
          mkdir -p /tmp/picotls-build/picotls-build
          cmake -S /tmp/picotls-build/picotls -B /tmp/picotls-build/picotls-build \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_SYSTEM_NAME=Linux \
            -DCMAKE_SYSTEM_PROCESSOR=aarch64 \
            -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc \
            -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++ \
            -DCMAKE_AR=/usr/bin/aarch64-linux-gnu-gcc-ar \
            -DCMAKE_RANLIB=/usr/bin/aarch64-linux-gnu-gcc-ranlib \
            -DCMAKE_FIND_ROOT_PATH=/tmp/openssl-aarch64\;/usr/aarch64-linux-gnu \
            -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
            -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
            -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
            -DOPENSSL_ROOT_DIR=/tmp/openssl-aarch64 \
            -DOPENSSL_INCLUDE_DIR=/tmp/openssl-aarch64/include \
            -DOPENSSL_CRYPTO_LIBRARY=/tmp/openssl-aarch64/lib/libcrypto.a \
            -DOPENSSL_SSL_LIBRARY=/tmp/openssl-aarch64/lib/libssl.a

          # Build only the library targets, not tests
          cmake --build /tmp/picotls-build/picotls-build --target picotls-core picotls-minicrypto picotls-openssl

          echo "âœ… Built picotls libraries for aarch64"
          ls -la /tmp/picotls-build/picotls-build/*.a

      - name: Build picoquic (aarch64)
        run: |
          ROOT_DIR="$PWD"
          PICOQUIC_DIR="${ROOT_DIR}/vendor/picoquic"
          BUILD_DIR="${ROOT_DIR}/.picoquic-build"
          PICOQUIC_PATCHED_PTLS="/tmp/picotls-build"
          PICOQUIC_PATCHED_PTLS_BUILD="/tmp/picotls-build/picotls-build"

          echo "Building picoquic for aarch64..."

          # Configure with the pre-built picotls for aarch64
          cmake -S "${PICOQUIC_DIR}" -B "${BUILD_DIR}" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_SYSTEM_NAME=Linux \
            -DCMAKE_SYSTEM_PROCESSOR=aarch64 \
            -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc \
            -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++ \
            -DCMAKE_AR=/usr/bin/aarch64-linux-gnu-gcc-ar \
            -DCMAKE_RANLIB=/usr/bin/aarch64-linux-gnu-gcc-ranlib \
            -DCMAKE_FIND_ROOT_PATH=/tmp/openssl-aarch64\;/usr/aarch64-linux-gnu \
            -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
            -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
            -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
            -DOPENSSL_ROOT_DIR=/tmp/openssl-aarch64 \
            -DOPENSSL_INCLUDE_DIR=/tmp/openssl-aarch64/include \
            -DOPENSSL_CRYPTO_LIBRARY=/tmp/openssl-aarch64/lib/libcrypto.a \
            -DOPENSSL_SSL_LIBRARY=/tmp/openssl-aarch64/lib/libssl.a \
            -DPICOQUIC_FETCH_PTLS=OFF \
            -DPTLS_INCLUDE_DIR="${PICOQUIC_PATCHED_PTLS}/picotls/include" \
            -DPTLS_CORE_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-core.a" \
            -DPTLS_OPENSSL_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-openssl.a" \
            -DPTLS_MINICRYPTO_LIBRARY="${PICOQUIC_PATCHED_PTLS_BUILD}/libpicotls-minicrypto.a"

          # Build picoquic
          cmake --build "${BUILD_DIR}"

          echo "âœ… Picoquic built successfully for aarch64"

          echo ""
          echo "=== Picoquic library files (.a) ==="
          find "${BUILD_DIR}" -name "*.a" | sort

      - name: Copy picotls libraries for Rust build
        run: |
          # The Rust build script expects picotls libs in _deps/picotls-build
          mkdir -p .picoquic-build/_deps/picotls-build

          # Copy picotls libraries
          echo "Copying picotls libraries..."
          for lib in /tmp/picotls-build/picotls-build/libpicotls-*.a; do
            if [ -f "$lib" ]; then
              cp "$lib" .picoquic-build/_deps/picotls-build/
              echo "âœ“ Copied: $(basename $lib)"
            fi
          done

          echo ""
          echo "=== Copied picotls libraries ==="
          ls -la .picoquic-build/_deps/picotls-build/

      - name: Set environment for static build
        run: |
          echo "OPENSSL_DIR=/tmp/openssl-aarch64" >> $GITHUB_ENV
          echo "OPENSSL_LIB_DIR=/tmp/openssl-aarch64/lib" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=/tmp/openssl-aarch64/include" >> $GITHUB_ENV
          echo "OPENSSL_STATIC=1" >> $GITHUB_ENV
          echo "PICOQUIC_AUTO_BUILD=0" >> $GITHUB_ENV
          echo "PICOQUIC_BUILD_DIR=$PWD/.picoquic-build" >> $GITHUB_ENV
          echo "PICOTLS_INCLUDE_DIR=/tmp/picotls-build/picotls/include" >> $GITHUB_ENV
          echo "CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc" >> $GITHUB_ENV
          echo "AR_aarch64_unknown_linux_gnu=aarch64-linux-gnu-ar" >> $GITHUB_ENV
          echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV

      - name: Build client (aarch64)
        run: |
          echo "Building slipstream-client for aarch64..."
          cargo build --release --target aarch64-unknown-linux-gnu -p slipstream-client
          echo "âœ… Client built successfully"

      - name: Verify static linking
        run: |
          BINARY="target/aarch64-unknown-linux-gnu/release/slipstream-client"

          echo "=== Binary information ==="
          file "$BINARY"

          echo ""
          echo "=== File size (before strip) ==="
          ls -lh "$BINARY"

          echo ""
          echo "=== Stripping debug symbols ==="
          aarch64-linux-gnu-strip "$BINARY"
          echo "Final size:"
          ls -lh "$BINARY"

      - name: Create release package
        run: |
          mkdir -p release/slipstream-client
          cp target/aarch64-unknown-linux-gnu/release/slipstream-client release/slipstream-client/

          cat > release/slipstream-client/client.conf << 'EOF'
          # Slipstream Client Configuration
          DOMAIN=tunnel.example.com
          RESOLVER=YOUR_SERVER_IP:53
          TCP_LISTEN_PORT=7000
          CONGESTION_CONTROL=dcubic
          EOF

          cat > release/slipstream-client/start-client.sh << 'EOF'
          #!/bin/bash
          set -e

          if [ ! -f client.conf ]; then
              echo "âŒ Error: client.conf not found"
              exit 1
          fi

          source client.conf

          if [ "$RESOLVER" = "YOUR_SERVER_IP:53" ]; then
              echo "âŒ Error: Configure RESOLVER in client.conf"
              exit 1
          fi

          echo "================================================"
          echo "  Slipstream DNS Tunnel Client (ARM64)"
          echo "================================================"
          echo ""
          echo "Configuration:"
          echo "  Domain      : ${DOMAIN}"
          echo "  Resolver    : ${RESOLVER}"
          echo "  Listen Port : ${TCP_LISTEN_PORT}"
          echo ""

          echo "Starting client..."
          echo "Press Ctrl+C to stop"
          echo ""

          ./slipstream-client \
            --domain ${DOMAIN} \
            --resolver ${RESOLVER} \
            --tcp-listen-port ${TCP_LISTEN_PORT} \
            --congestion-control ${CONGESTION_CONTROL}
          EOF
          chmod +x release/slipstream-client/start-client.sh

          cat > release/slipstream-client/README.md << 'EOF'
          # Slipstream Client - Linux ARM64 (Fully Static)

          âœ… **Zero runtime dependencies - Works on ANY ARM64 Linux**

          ## Quick Start

          ```bash
          # 1. Configure (edit client.conf)
          nano client.conf

          # 2. Run
          ./start-client.sh

          # 3. Use SOCKS5 proxy
          curl --proxy socks5://127.0.0.1:7000 http://example.com
          ```

          ## Requirements

          **To run the client**: NOTHING (fully static binary)

          Works on: Any ARM64 Linux (AWS Graviton, Oracle ARM, Raspberry Pi 4+, etc.)

          ## Configuration

          Edit `client.conf`:
          - `DOMAIN`: Your tunnel domain (e.g., tunnel.example.com)
          - `RESOLVER`: DNS server IP (your server's IP)
          - `TCP_LISTEN_PORT`: Local SOCKS5 proxy port (default: 7000)
          - `CONGESTION_CONTROL`: Congestion algorithm (dcubic, bbr, cubic)

          ## Documentation

          https://github.com/Mygod/slipstream-rust
          EOF

          cd release
          tar -czf slipstream-client-linux-aarch64-static.tar.gz slipstream-client/

          echo ""
          echo "=== Package created ==="
          ls -lh *.tar.gz

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: slipstream-client-linux-aarch64-static
          path: release/*.tar.gz

  create-release:
    name: Create GitHub Release
    needs: [build-linux, build-linux-client, build-linux-server-aarch64, build-linux-client-aarch64]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: artifacts/**/*.tar.gz
          generate_release_notes: true
          body: |
            ## ðŸš€ Standalone Linux Executables - Zero Dependencies

            ### Linux Server (x86_64)
            - **File**: `slipstream-server-linux-x64-static.tar.gz`
            - **Static MUSL binary** - works on ANY x86_64 Linux
            - **No dependencies** required to run

            ### Linux Client (x86_64)
            - **File**: `slipstream-client-linux-x64-static.tar.gz`
            - **Static MUSL binary** - works on ANY x86_64 Linux
            - **No dependencies** required to run

            ### Linux Server (ARM64/aarch64)
            - **File**: `slipstream-server-linux-aarch64-static.tar.gz`
            - **Static MUSL binary** - works on ANY ARM64 Linux
            - For AWS Graviton, Oracle ARM, Raspberry Pi 4+, etc.

            ### Linux Client (ARM64/aarch64)
            - **File**: `slipstream-client-linux-aarch64-static.tar.gz`
            - **Static MUSL binary** - works on ANY ARM64 Linux
            - For AWS Graviton, Oracle ARM, Raspberry Pi 4+, etc.

            ### Quick Start
            1. Download the appropriate package for your architecture
            2. Extract and configure
            3. Run startup script

            > **Note**: Windows support is not currently available due to platform dependencies.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
